/* tslint:disable */
/* eslint-disable */
/**
 * DIXA API
 * Project DIXA API, documentation management
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { Account } from '../models';
import { InlineResponse2002 } from '../models';
import { InlineResponse2003 } from '../models';
import { InlineResponse400 } from '../models';
import { InlineResponse401 } from '../models';
import { InlineResponse403 } from '../models';
import { InlineResponse404 } from '../models';
import { InlineResponse422 } from '../models';
import { UpdatePassword } from '../models';
import { User } from '../models';
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * user information for the currently authenticated platform
         * @summary Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * update password of user in the system
         * @summary Change Password - User
         * @param {number} userId user id
         * @param {UpdatePassword} [body] Request in json format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUser: async (userId: number, body?: UpdatePassword, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling changePasswordUser.');
            }
            const localVarPath = `/users/{user_id}/change-password`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * create a user in the system
         * @summary Create - Users
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [lastname] 
         * @param {string} [secondLastname] 
         * @param {string} [phone] 
         * @param {string} [password] 
         * @param {string} [imageFile] 
         * @param {number} [roleId] 
         * @param {number} [departmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsers: async (email?: string, name?: string, lastname?: string, secondLastname?: string, phone?: string, password?: string, imageFile?: string, roleId?: number, departmentId?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required


            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }

            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }

            if (lastname !== undefined) { 
                localVarFormParams.append('lastname', lastname as any);
            }

            if (secondLastname !== undefined) { 
                localVarFormParams.append('second_lastname', secondLastname as any);
            }

            if (phone !== undefined) { 
                localVarFormParams.append('phone', phone as any);
            }

            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }

            if (imageFile !== undefined) { 
                localVarFormParams.append('image_file', imageFile as any);
            }

            if (roleId !== undefined) { 
                localVarFormParams.append('role_id', roleId as any);
            }

            if (departmentId !== undefined) { 
                localVarFormParams.append('department_id', departmentId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * remove image avatar the user authenticate
         * @summary Delete - imagen user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImageUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the user in a single request
         * @summary Get - Users
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser: async (userId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the list of all users in a single request
         * @summary List - Users
         * @param {string} [name] Value to filter by full user name
         * @param {number} [role] (role id) Value to filter the role type of the users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (name?: string, role?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * filter users with pagination included
         * @summary Search - Users
         * @param {number} [role] (role id) Value to filter the role type of the users
         * @param {string} [name] Value to filter by full user name
         * @param {number} [page] page to query
         * @param {number} [perPage] number of items you want the response to return
         * @param {string} [order] sort type, descending or ascending
         * @param {string} [sortBy] field by which you want to sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers: async (role?: number, name?: string, page?: number, perPage?: number, order?: string, sortBy?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required

            if (role !== undefined) {
                localVarQueryParameter['role'] = role;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (perPage !== undefined) {
                localVarQueryParameter['perPage'] = perPage;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * update image the user authenticate
         * @summary Update - image user
         * @param {string} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageUser: async (image?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * update a user in the system
         * @summary Update - User
         * @param {number} userId user id
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [lastname] 
         * @param {string} [secondLastname] 
         * @param {string} [phone] 
         * @param {string} [password] 
         * @param {string} [imageFile] 
         * @param {number} [roleId] 
         * @param {number} [departmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (userId: number, email?: string, name?: string, lastname?: string, secondLastname?: string, phone?: string, password?: string, imageFile?: string, roleId?: number, departmentId?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearerAuth required


            if (email !== undefined) { 
                localVarFormParams.append('email', email as any);
            }

            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }

            if (lastname !== undefined) { 
                localVarFormParams.append('lastname', lastname as any);
            }

            if (secondLastname !== undefined) { 
                localVarFormParams.append('second_lastname', secondLastname as any);
            }

            if (phone !== undefined) { 
                localVarFormParams.append('phone', phone as any);
            }

            if (password !== undefined) { 
                localVarFormParams.append('password', password as any);
            }

            if (imageFile !== undefined) { 
                localVarFormParams.append('image_file', imageFile as any);
            }

            if (roleId !== undefined) { 
                localVarFormParams.append('role_id', roleId as any);
            }

            if (departmentId !== undefined) { 
                localVarFormParams.append('department_id', departmentId as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * user information for the currently authenticated platform
         * @summary Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async account(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).account(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * update password of user in the system
         * @summary Change Password - User
         * @param {number} userId user id
         * @param {UpdatePassword} [body] Request in json format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changePasswordUser(userId: number, body?: UpdatePassword, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).changePasswordUser(userId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * create a user in the system
         * @summary Create - Users
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [lastname] 
         * @param {string} [secondLastname] 
         * @param {string} [phone] 
         * @param {string} [password] 
         * @param {string} [imageFile] 
         * @param {number} [roleId] 
         * @param {number} [departmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsers(email?: string, name?: string, lastname?: string, secondLastname?: string, phone?: string, password?: string, imageFile?: string, roleId?: number, departmentId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).createUsers(email, name, lastname, secondLastname, phone, password, imageFile, roleId, departmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * remove image avatar the user authenticate
         * @summary Delete - imagen user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteImageUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).deleteImageUser(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the user in a single request
         * @summary Get - Users
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUser(userId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUser(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get the list of all users in a single request
         * @summary List - Users
         * @param {string} [name] Value to filter by full user name
         * @param {number} [role] (role id) Value to filter the role type of the users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(name?: string, role?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).getUsers(name, role, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * filter users with pagination included
         * @summary Search - Users
         * @param {number} [role] (role id) Value to filter the role type of the users
         * @param {string} [name] Value to filter by full user name
         * @param {number} [page] page to query
         * @param {number} [perPage] number of items you want the response to return
         * @param {string} [order] sort type, descending or ascending
         * @param {string} [sortBy] field by which you want to sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUsers(role?: number, name?: string, page?: number, perPage?: number, order?: string, sortBy?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).searchUsers(role, name, page, perPage, order, sortBy, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * update image the user authenticate
         * @summary Update - image user
         * @param {string} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateImageUser(image?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateImageUser(image, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * update a user in the system
         * @summary Update - User
         * @param {number} userId user id
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [lastname] 
         * @param {string} [secondLastname] 
         * @param {string} [phone] 
         * @param {string} [password] 
         * @param {string} [imageFile] 
         * @param {number} [roleId] 
         * @param {number} [departmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(userId: number, email?: string, name?: string, lastname?: string, secondLastname?: string, phone?: string, password?: string, imageFile?: string, roleId?: number, departmentId?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await UsersApiAxiosParamCreator(configuration).updateUser(userId, email, name, lastname, secondLastname, phone, password, imageFile, roleId, departmentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * user information for the currently authenticated platform
         * @summary Account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        account(options?: any): AxiosPromise<Account> {
            return UsersApiFp(configuration).account(options).then((request) => request(axios, basePath));
        },
        /**
         * update password of user in the system
         * @summary Change Password - User
         * @param {number} userId user id
         * @param {UpdatePassword} [body] Request in json format
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changePasswordUser(userId: number, body?: UpdatePassword, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).changePasswordUser(userId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * create a user in the system
         * @summary Create - Users
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [lastname] 
         * @param {string} [secondLastname] 
         * @param {string} [phone] 
         * @param {string} [password] 
         * @param {string} [imageFile] 
         * @param {number} [roleId] 
         * @param {number} [departmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsers(email?: string, name?: string, lastname?: string, secondLastname?: string, phone?: string, password?: string, imageFile?: string, roleId?: number, departmentId?: number, options?: any): AxiosPromise<InlineResponse2003> {
            return UsersApiFp(configuration).createUsers(email, name, lastname, secondLastname, phone, password, imageFile, roleId, departmentId, options).then((request) => request(axios, basePath));
        },
        /**
         * remove image avatar the user authenticate
         * @summary Delete - imagen user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteImageUser(options?: any): AxiosPromise<InlineResponse2003> {
            return UsersApiFp(configuration).deleteImageUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the user in a single request
         * @summary Get - Users
         * @param {number} userId user id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUser(userId: number, options?: any): AxiosPromise<InlineResponse2003> {
            return UsersApiFp(configuration).getUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the list of all users in a single request
         * @summary List - Users
         * @param {string} [name] Value to filter by full user name
         * @param {number} [role] (role id) Value to filter the role type of the users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(name?: string, role?: number, options?: any): AxiosPromise<InlineResponse2002> {
            return UsersApiFp(configuration).getUsers(name, role, options).then((request) => request(axios, basePath));
        },
        /**
         * filter users with pagination included
         * @summary Search - Users
         * @param {number} [role] (role id) Value to filter the role type of the users
         * @param {string} [name] Value to filter by full user name
         * @param {number} [page] page to query
         * @param {number} [perPage] number of items you want the response to return
         * @param {string} [order] sort type, descending or ascending
         * @param {string} [sortBy] field by which you want to sort
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUsers(role?: number, name?: string, page?: number, perPage?: number, order?: string, sortBy?: string, options?: any): AxiosPromise<InlineResponse2002> {
            return UsersApiFp(configuration).searchUsers(role, name, page, perPage, order, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * update image the user authenticate
         * @summary Update - image user
         * @param {string} [image] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateImageUser(image?: string, options?: any): AxiosPromise<InlineResponse2003> {
            return UsersApiFp(configuration).updateImageUser(image, options).then((request) => request(axios, basePath));
        },
        /**
         * update a user in the system
         * @summary Update - User
         * @param {number} userId user id
         * @param {string} [email] 
         * @param {string} [name] 
         * @param {string} [lastname] 
         * @param {string} [secondLastname] 
         * @param {string} [phone] 
         * @param {string} [password] 
         * @param {string} [imageFile] 
         * @param {number} [roleId] 
         * @param {number} [departmentId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(userId: number, email?: string, name?: string, lastname?: string, secondLastname?: string, phone?: string, password?: string, imageFile?: string, roleId?: number, departmentId?: number, options?: any): AxiosPromise<User> {
            return UsersApiFp(configuration).updateUser(userId, email, name, lastname, secondLastname, phone, password, imageFile, roleId, departmentId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * user information for the currently authenticated platform
     * @summary Account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public account(options?: any) {
        return UsersApiFp(this.configuration).account(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update password of user in the system
     * @summary Change Password - User
     * @param {number} userId user id
     * @param {UpdatePassword} [body] Request in json format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public changePasswordUser(userId: number, body?: UpdatePassword, options?: any) {
        return UsersApiFp(this.configuration).changePasswordUser(userId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * create a user in the system
     * @summary Create - Users
     * @param {string} [email] 
     * @param {string} [name] 
     * @param {string} [lastname] 
     * @param {string} [secondLastname] 
     * @param {string} [phone] 
     * @param {string} [password] 
     * @param {string} [imageFile] 
     * @param {number} [roleId] 
     * @param {number} [departmentId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUsers(email?: string, name?: string, lastname?: string, secondLastname?: string, phone?: string, password?: string, imageFile?: string, roleId?: number, departmentId?: number, options?: any) {
        return UsersApiFp(this.configuration).createUsers(email, name, lastname, secondLastname, phone, password, imageFile, roleId, departmentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * remove image avatar the user authenticate
     * @summary Delete - imagen user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteImageUser(options?: any) {
        return UsersApiFp(this.configuration).deleteImageUser(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the user in a single request
     * @summary Get - Users
     * @param {number} userId user id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUser(userId: number, options?: any) {
        return UsersApiFp(this.configuration).getUser(userId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get the list of all users in a single request
     * @summary List - Users
     * @param {string} [name] Value to filter by full user name
     * @param {number} [role] (role id) Value to filter the role type of the users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUsers(name?: string, role?: number, options?: any) {
        return UsersApiFp(this.configuration).getUsers(name, role, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * filter users with pagination included
     * @summary Search - Users
     * @param {number} [role] (role id) Value to filter the role type of the users
     * @param {string} [name] Value to filter by full user name
     * @param {number} [page] page to query
     * @param {number} [perPage] number of items you want the response to return
     * @param {string} [order] sort type, descending or ascending
     * @param {string} [sortBy] field by which you want to sort
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public searchUsers(role?: number, name?: string, page?: number, perPage?: number, order?: string, sortBy?: string, options?: any) {
        return UsersApiFp(this.configuration).searchUsers(role, name, page, perPage, order, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update image the user authenticate
     * @summary Update - image user
     * @param {string} [image] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateImageUser(image?: string, options?: any) {
        return UsersApiFp(this.configuration).updateImageUser(image, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * update a user in the system
     * @summary Update - User
     * @param {number} userId user id
     * @param {string} [email] 
     * @param {string} [name] 
     * @param {string} [lastname] 
     * @param {string} [secondLastname] 
     * @param {string} [phone] 
     * @param {string} [password] 
     * @param {string} [imageFile] 
     * @param {number} [roleId] 
     * @param {number} [departmentId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(userId: number, email?: string, name?: string, lastname?: string, secondLastname?: string, phone?: string, password?: string, imageFile?: string, roleId?: number, departmentId?: number, options?: any) {
        return UsersApiFp(this.configuration).updateUser(userId, email, name, lastname, secondLastname, phone, password, imageFile, roleId, departmentId, options).then((request) => request(this.axios, this.basePath));
    }
}
